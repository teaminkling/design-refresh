import Work from "../../../data/core/Work";
import {WORKS_WITH_ARTIST_INDEX, WORKS_WITH_ID_INDEX, WORKS_WITH_WEEK_INDEX} from "../constants/kv";
import {ACTIVE_YEAR} from "../constants/setup";
import {validateIsStaff} from "../utils/auth";
import {createJsonResponse, createNotFoundResponse} from "../utils/http";
import {determineShortId, sanitize} from "../utils/io";

/**
 * Handlers for works endpoints.
 */

/**
 * Using search terms, retrieve the works.
 *
 * Full index retrieval is possible and acceptable as egress is not billed. It is just slow for
 * the user so the web client does not use it.
 *
 * Unpublished works are not included in the output.
 *
 * Sorting and direct member searching is not possible through this endpoint. It is expected to
 * be done on the frontend as repeated changes of the sort and search would waste backend calls.
 *
 * Params pattern: `?year=<year>&week=<week>&artist=<artist>`
 *
 * @param {URLSearchParams} params the search parameters
 * @param {KVNamespace} kv the main key-value store
 * @param {KVNamespace} authKv the auth key-value store
 * @param {string | null} identifier the identifier of the calling user
 * @returns {Promise<Response>} the response
 */
export const getWorks = async (
  params: URLSearchParams, kv: KVNamespace, authKv: KVNamespace, identifier: string | null,
): Promise<Response> => {
  // Escape search terms (remove slashes).

  const year: string | null = sanitize(params.get("year"));
  const week: string | null = sanitize(params.get("week"));
  const artist: string | null = sanitize(params.get("artist"));

  // If the artist is present, that cancels the most results, so use that as search. Otherwise
  // use the week. If neither are present, we will squash the results down.

  let results: Work[] = [];
  if (artist) {
    const works_with_artist_index: Record<string, Work[]> = JSON.parse(
      (await kv.get(`${WORKS_WITH_ARTIST_INDEX}`)) || "{}",
    );

    (works_with_artist_index[artist] || []).forEach((work: Work) => {
      results.push(work);
    });
  } else {
    const works_with_week_index: Record<string, Work[]> = JSON.parse(
      (await kv.get(`${WORKS_WITH_WEEK_INDEX}`)) || "{}",
    );

    if (week) {
      // Use the active year if the year is not specified.

      (works_with_week_index[`${year || ACTIVE_YEAR}/${week}`] || []).forEach((work: Work) => {
        results.push(work);
      });
    } else {
      Object.keys(works_with_week_index).forEach(
        (key: string) => {
          works_with_week_index[key].forEach((work: Work) => results.push(work));
        }
      );
    }
  }

  // The output currently has all works, not just published ones. Check the auth now. If it's
  // not a staff user, remove things from the output. No need to check for ownership: if the
  // requesting user called this, their posts should be in local storage already.

  const isStaff: boolean = identifier ? await validateIsStaff(identifier, authKv) : false;
  if (!isStaff) {
    results = results.filter((result: Work) => result.isApproved);
  }

  return createJsonResponse(JSON.stringify({data: results}));
};

/**
 * Retrieve a single post by ID.
 *
 * There is no authentication check.
 *
 * @param {URLSearchParams} params the search parameters
 * @param {Body} _body the unused body
 * @param {KVNamespace} kv the key-value store
 * @returns {Promise<Response>} the response
 */
export const getWork = async (
  params: URLSearchParams, _body: Body, kv: KVNamespace,
): Promise<Response> => {
  const id: string | null = sanitize(params.get("id"));
  if (!id) {
    return createNotFoundResponse();
  }

  const works_with_id_index: Record<string, Work> = JSON.parse(
    (await kv.get(WORKS_WITH_ID_INDEX)) || "{}"
  );

  const work: Work | undefined | null = works_with_id_index[id];
  if (!work) {
    return createNotFoundResponse();
  }

  return createJsonResponse(JSON.stringify({data: work}));
};

/**
 * Create or update a post in the database.
 *
 * The ID provided by the user is used to find an existing post. If it doesn't exist, the ID is
 * ignored and generated by the backend.
 *
 * This is an idempotent endpoint whether or not a post already exists. It uses a rate limit of 2
 * edits per minute. We are not concerned about race conditions.
 *
 * @param {Request} request the request
 * @param {KVNamespace} kv the main key-value store
 * @param {KVNamespace} authKv the auth key-value store
 * @param {string | null} identifier the identifier of the calling user
 * @returns {Promise<Response>} the response
 */
export const putWork = async (
  request: Request, kv: KVNamespace, authKv: KVNamespace, identifier: string | null,
): Promise<Response> => {
  // Ensure user is authenticated at all before doing any other CPU computation.

  if (!identifier) {
    return createNotFoundResponse();
  }

  // Validate all data and ensure it is escaped for HTML.

  // TODO

  const input: Work = await request.json();

  // If the work exists, validate that the user PUTing is a staff member or the creating user.
  // There is no need to validate credentials of a user if the

  const rawBackendWork: string | null = await kv.get(`${WORKS_WITH_ID_INDEX}/${input.id}`);
  const backendWork: Work | null = rawBackendWork ? JSON.parse(rawBackendWork) : null;

  let effectiveId: string = input.id;
  if (backendWork) {
    const isStaff: boolean = identifier ? await validateIsStaff(identifier, authKv) : false;
    if (!isStaff || input.artistId !== backendWork.artistId) {
      return createNotFoundResponse();
    }

    // TODO: Edit indices.
  } else {
    // Determine what the ID should be, ignoring what the user put.

    const newId: string = await determineShortId(input.artistId, input.urls);

    // Check that there isn't a work at that endpoint. This isn't very robust, but we don't ever
    // expect anything to ever collide.

    if (await kv.get(`${WORKS_WITH_ID_INDEX}/${newId}`)) {
      throw new Error("Collision error! This requires developer intervention.");
    }

    effectiveId = newId;

    // TODO: Add indices.
  }

  // TODO: Do the actual update of all three indices.

  // Edit the Discord post for this work (can fail without 500).

  // TODO

  return createJsonResponse();
};

// TODO: Rate limit: 8 uploads a minute.

export const postUpload = async (
  _params: URLSearchParams, _body: Body, _kv: KVNamespace,
): Promise<Response> => {

  // TODO

  return createJsonResponse();
};
